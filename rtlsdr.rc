extern mod extra;

use std::num;
use extra::complex;
use extra::time;

mod kissfft;
mod video;
mod rtlsdr;
mod pa;
mod dsputils;

fn asRe ( d: ~[f32] ) -> ~[complex::Complex32] { return d.iter().transform(|&x| {complex::Cmplx {re: x, im: 0.0}}).collect::<~[complex::Complex32]>();}
fn asF32 ( d: ~[complex::Complex32] ) -> ~[f32] { return d.iter().transform(|&x| {if (num::abs(x.im) < 0.001) { x.re } else { let (m,p) = x.to_polar(); m*num::signum(p) }}).collect::<~[f32]>(); }
fn asF64 ( d: ~[f32] ) -> ~[f64] { return d.iter().transform(|&x| x as f64).collect(); }
fn main() {
	let devHandle = rtlsdr::openDevice(0);
	rtlsdr::setSampleRate(devHandle, 881000);
	rtlsdr::clearBuffer(devHandle);
	rtlsdr::setGainAuto(devHandle);
	rtlsdr::setFrequency(devHandle, 87900000);
	let (keystrokePort, videoChan) = video::spawnVectorVisualSink();
	let pi: f32 = num::atan2(1f32,1f32) * 4f32;
	let co = pa::buildPASinkBlock(44100);
	// len 511 complex-coefficiented, real-valued block filter, padded to 8192
	let filter: ~[f32] = dsputils::lpf(511, 20e3/881e3);
	let paddedFilter: ~[f32] = ~[0.0f32, ..3840] + filter + ~[0.0f32, ..3841];
	let filterFFTd: ~[complex::Complex32] = kissfft::FFT(asRe(paddedFilter));
	let pdata = rtlsdr::readAsync(devHandle);
	loop {
		let start = time::precise_time_ns();
		// 8192-512 \pm 1 complex-typed samples
		let mut samples: ~[complex::Complex32] = ~[];
		loop {
			samples = samples + rtlsdr::dataToSamples(pdata.recv());
			if (samples.len() == (512*15)) {break};
		}
		// phase of complex numbers
		let phase: ~[f32] = samples.iter().transform(|&x| num::atan2(x.im, x.re)).collect();
		let dpdt: ~[f32] = phase.window_iter(2).transform(|x| {
			let mut dx = x[0]-x[1];
			if (dx < -pi) {dx = dx + 2f32*pi};
			if (dx > pi) {dx = dx - 2f32*pi};
			dx}
			).collect::<~[f32]>();
		//videoChan.send(dpdt.clone());
		// 15 * 512 = 7679
		let paddedData = asRe(~[0.0f32, ..256]) + asRe(dpdt) + asRe(~[0.0f32, ..257]);
		// multiply DFT'd filter coefficients by DFT'd data - implement overlap-scrap fast convolution
		// - http://www.dspguide.com/ch12/1.htm
		// - https://en.wikipedia.org/wiki/Overlap%E2%80%93add_method
		// - http://www.cs.princeton.edu/courses/archive/spr05/cos423/lectures/05fft.pdf
		let datafft = kissfft::FFT(paddedData);
		let convolved: ~[complex::Complex32] = datafft.iter().zip(filterFFTd.iter()).transform(|(&x, &y)| {x*y}).collect();
		let filtered: ~[f32] = asF32(kissfft::iFFT(convolved));
		let trimmed: ~[f32] = filtered.iter().enumerate().filter(|&(x, &y)| (256<x)  && (x<=((8192/2)-256))).transform(|(x, &y)| y).collect();
		// too-clever downsampling to ensure consistent 44.1k sample rate 
		let samples = (time::precise_time_ns() - start) as f32 * 44.1e-6;
		let len = trimmed.len() as f32;
		let downsampleFactor = samples/len;
		let downsampled: ~[f32] = trimmed.iter().enumerate().filter(|&(x, &y)|
			((x as f32*downsampleFactor) - (x as f32*downsampleFactor).floor()) < downsampleFactor
			).transform(|(x, &y)| y).collect();
		videoChan.send(downsampled.clone());
		co.send(downsampled);
	}
}
